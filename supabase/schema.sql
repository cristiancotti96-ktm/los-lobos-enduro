-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create Enum for vehicle types
CREATE TYPE vehicle_type AS ENUM ('Buggy', 'Quad', 'Enduro', '4x4', 'UTV');

-- Create Profiles table (Extends auth.users)
CREATE TABLE public.profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  username TEXT UNIQUE,
  full_name TEXT,
  vehicle_type vehicle_type DEFAULT 'Enduro',
  emergency_contact TEXT,
  avatar_url TEXT,
  is_admin BOOLEAN DEFAULT FALSE,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create Events table
CREATE TABLE public.eventos (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  titulo TEXT NOT NULL,
  descripcion TEXT,
  precio NUMERIC NOT NULL DEFAULT 0,
  fecha TIMESTAMP WITH TIME ZONE NOT NULL,
  ubicacion_gpx TEXT, -- URL to GPX file in storage
  dificultad TEXT CHECK (dificultad IN ('Facil', 'Medio', 'Dificil', 'Extremo', 'Leyenda')),
  max_participantes INTEGER,
  imagen_url TEXT -- URL to event cover image
);

-- Create Registration (Inscripciones) table
CREATE TABLE public.inscripciones (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  evento_id BIGINT REFERENCES public.eventos(id) ON DELETE CASCADE NOT NULL,
  status_pago TEXT DEFAULT 'pending' CHECK (status_pago IN ('pending', 'paid', 'failed', 'refunded')),
  monto_pagado NUMERIC DEFAULT 0,
  stripe_payment_intent_id TEXT,
  UNIQUE(user_id, evento_id)
);

-- Enable Row Level Security (RLS)
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.eventos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.inscripciones ENABLE ROW LEVEL SECURITY;

-- Policies for Profiles
-- Public profiles are viewable by everyone
CREATE POLICY "Public profiles are viewable by everyone." 
ON public.profiles FOR SELECT 
USING (true);

-- Users can insert their own profile
CREATE POLICY "Users can insert their own profile." 
ON public.profiles FOR INSERT 
WITH CHECK (auth.uid() = id);

-- Users can update their own profile
CREATE POLICY "Users can update own profile." 
ON public.profiles FOR UPDATE 
USING (auth.uid() = id);

-- Policies for Events
-- Events are viewable by everyone
CREATE POLICY "Eventos are viewable by everyone." 
ON public.eventos FOR SELECT 
USING (true);

-- Only admins can insert/update/delete events
-- We assume a custom claim or a check against the profiles table for is_admin
-- For simplicity, we'll allow service_role (which is admin) and checks against profiles.is_admin
CREATE POLICY "Admins can insert events." 
ON public.eventos FOR INSERT 
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE id = auth.uid() AND is_admin = true
  )
);

CREATE POLICY "Admins can update events." 
ON public.eventos FOR UPDATE 
USING (
  EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE id = auth.uid() AND is_admin = true
  )
);

CREATE POLICY "Admins can delete events." 
ON public.eventos FOR DELETE 
USING (
  EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE id = auth.uid() AND is_admin = true
  )
);

-- Policies for Inscripciones (Registrations)
-- Users can view their own registrations
CREATE POLICY "Users can view own inscripciones." 
ON public.inscripciones FOR SELECT 
USING (auth.uid() = user_id);

-- Admins can view all registrations
CREATE POLICY "Admins can view all inscripciones." 
ON public.inscripciones FOR SELECT 
USING (
  EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE id = auth.uid() AND is_admin = true
  )
);

-- Users can create a registration (initially pending)
CREATE POLICY "Users can create inscripcion." 
ON public.inscripciones FOR INSERT 
WITH CHECK (auth.uid() = user_id);

-- Webhooks or server-side logic (using service_role) will handle status updates for payments. 
-- However, if we want to allow users to update strictly for some reason (e.g., cancelling), we can add valid policies.

-- Function to handle new user signup (Trigger)
CREATE OR REPLACE FUNCTION public.handle_new_user() 
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, avatar_url)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to create profile on signup
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Storage Buckets (Execute in SQL Editor manually if needed, or via client)
-- insert into storage.buckets (id, name, public) values ('event-images', 'event-images', true);
